#include "FilePropertiesManager.hh"
#include "HistUtils.hh"


// Script intended to help with choosing binning for kinematic variables

// The anticipated POT to use when scaling the MC prediction in the expected
// reco events plot. This will help ensure that all choices of reco binning
// are informed by the expected statistical uncertainties when the full dataset
// is analyzed.
constexpr double EXPECTED_POT = 6.790e20; // Full dataset for Runs 1-3

// Number of true bins to use when plotting true distributions in a given
// reco bin
constexpr int DEFAULT_TRUE_BINS = 100;

// ROOT integer code for Arial font
constexpr int FONT_STYLE = 62; // Arial

// When bins have zero content, set them to this very small value so that the
// colz style will still paint them
constexpr double REALLY_SMALL = 1e-11;


void make_res_plots( const std::string& branchexpr,
  const std::string& variable_title, const std::string& selection,
  const std::set<int>& runs, std::vector<double> bin_low_edges,
  bool show_bin_plots = true,
  bool show_smear_numbers = false,
  int num_true_bins = DEFAULT_TRUE_BINS,
  const std::string& mc_branchexpr = "",
  const std::string& signal_cuts = "mc_is_signal",
  const std::string& mc_event_weight = DEFAULT_MC_EVENT_WEIGHT )
{
  // Get the outer edges of the reco-space bins. This will be used to set the
  // plot range for the true-space histograms.
  double xmin = bin_low_edges.front();
  double xmax = bin_low_edges.back();

  // If the user hasn't explicitly specified a branch expression for the
  // true quantity, assume that it's the same as the reco quantity but
  // with the prefix "mc_" added.
  std::string true_branchexpr = mc_branchexpr;
  if ( true_branchexpr.empty() ) {
    true_branchexpr = "mc_" + branchexpr;
  }

  // Get access to the singleton utility class that manages the processed
  // ntuple files
  const FilePropertiesManager& fpm = FilePropertiesManager::Instance();

  // Make a TChain to process the CV numu ntuples from the requested run(s).
  // For the resolution studies, this is all we really need. Add the
  // appropriate ntuples to the TChain. Also tally the total simulated
  // POT for later scaling purposes.
  TChain chain( "stv_tree" );
  double total_simulated_POT = 0.;

  const auto& ntuple_map = fpm.ntuple_file_map();
  for ( const auto& run : runs ) {
    const auto& ntuple_files = ntuple_map.at( run )
      .at( NtupleFileType::kNumuMC );
    for ( const auto& file_name : ntuple_files ) {
      chain.Add( file_name.c_str() );

      TFile temp_file( file_name.c_str(), "read" );
      TParameter<float>* temp_pot = nullptr;
      temp_file.GetObject( "summed_pot", temp_pot );
      double pot = temp_pot->GetVal();
      total_simulated_POT += pot;
    }
  }

  // Dummy counter used to ensure that each histogram generated by this
  // function has a unique name to use with TTree::Draw()
  static int hist_count = 0;

  if ( show_bin_plots ) {
    for ( size_t b = 1u; b < bin_low_edges.size(); ++b ) {
      ++hist_count;

      TCanvas* c = new TCanvas;
      std::string true_hist_name = "true_hist" + std::to_string( hist_count );

      TH1D* true_hist = new TH1D( true_hist_name.c_str(),
        ("true events in " + variable_title + " reco bin "
        + std::to_string(b) + "; " + variable_title + "; events").c_str(),
        num_true_bins, xmin, xmax );

      double reco_bin_min = bin_low_edges.at( b - 1 );
      double reco_bin_max = bin_low_edges.at( b );
      std::string cuts = mc_event_weight + " * (is_mc && " + signal_cuts
        + " && " + selection + " && " + branchexpr + " >= "
        + std::to_string( reco_bin_min ) + " && " + branchexpr
        + " < " + std::to_string( reco_bin_max ) + ')';

      chain.Draw( (true_branchexpr + " >> " + true_hist_name).c_str(),
        cuts.c_str(), "goff" );

      true_hist->SetStats( false );
      true_hist->SetLineWidth( 2 );
      true_hist->SetLineColor( kBlack );

      true_hist->Draw( "hist pe" );

      // Prepare vertical lines to draw on the plot. These will show the
      // boundaries of the reco bin in true space
      double max_for_lines = std::numeric_limits<double>::max();

      TLine* line_bin_min = new TLine( reco_bin_min, 0.,
        reco_bin_min, max_for_lines );

      TLine* line_bin_max = new TLine( reco_bin_max, 0.,
        reco_bin_max, max_for_lines );

      line_bin_min->SetLineColor( kRed );
      line_bin_min->SetLineWidth( 2 );
      line_bin_min->SetLineStyle( 1 );
      line_bin_min->Draw( "same" );

      line_bin_max->SetLineColor( kRed );
      line_bin_max->SetLineWidth( 2 );
      line_bin_max->SetLineStyle( 1 );
      line_bin_max->Draw( "same" );

    } // loop over reco bins

  } // show bin plots

  // Also get the total number of reco bins for the 2D smearing plot
  int num_reco_bins = bin_low_edges.size() - 1u;

  // Compute the smearing matrix for a choice of true bins that exactly
  // match the ones in reco space.
  std::string smear_hist_name = "smear_hist" + std::to_string( hist_count );
  TH2D* smear_hist = new TH2D( smear_hist_name.c_str(),
    ("smearing matrix for " + variable_title + "; true " + variable_title
    + "; reco " + variable_title).c_str(), num_reco_bins, bin_low_edges.data(),
    num_reco_bins, bin_low_edges.data() );

  std::string smear_expr = branchexpr + " : " + true_branchexpr
    + " >> " + smear_hist_name;

  std::string smear_cuts = mc_event_weight + " * (is_mc && " + signal_cuts
    + " && " + selection + ')';

  chain.Draw( smear_expr.c_str(), smear_cuts.c_str(), "goff" );

  // Before renormalizing the smearing matrix histogram, take a projection
  // along the reco (y) axis. This will show the expected number of signal
  // events in each reco bin according to our central value MC model. Reco bins
  // should be chosen to have sufficient expected statistics in addition to
  // small smearing.
  TH1D* expected_reco_hist = smear_hist->ProjectionY();

  // Scale the expected reco bin counts to the POT analyzed for the full
  // dataset. Also set the bin stat uncertainties to the square root of their
  // contents. This is not correct for getting the MC statistical uncertainties
  // (which should use the sum of the squares of the weights to get the
  // variance), but we're less interested in those. Primarily we'd like to know
  // what the anticipated statistical uncertainties on the *measurement* will
  // be. We can estimate that by choosing the bin errors in this way. This will
  // help in the effort to choose suitable bins for reporting the final result.
  expected_reco_hist->Scale( EXPECTED_POT / total_simulated_POT );
  for ( int eb = 0; eb <= num_reco_bins + 1; ++eb ) {
    double bin_events = expected_reco_hist->GetBinContent( eb );
    double bin_stat_err = std::sqrt( std::max(0., bin_events) );
    expected_reco_hist->SetBinError( eb, bin_stat_err );
  }

  expected_reco_hist->SetStats( false );
  expected_reco_hist->SetLineColor( kBlack );
  expected_reco_hist->SetLineWidth( 2 );

  std::stringstream temp_ss;
  temp_ss << "expected reco bin counts (" << EXPECTED_POT << " POT);"
    << " reco " << variable_title << "; events";

  expected_reco_hist->SetTitle( temp_ss.str().c_str() );

  TCanvas* c_expected = new TCanvas;
  expected_reco_hist->Draw( "hist e" );

  // Normalize the smearing matrix elements so that a sum over all reco bins
  // (including the under/overflow bins) yields a value of one. This means that
  // every selected signal event must end up somewhere in reco space.
  int num_bins_x = smear_hist->GetXaxis()->GetNbins();
  int num_bins_y = smear_hist->GetYaxis()->GetNbins();

  // Loop over the true (x) bins. Include the underflow (index zero) and
  // overflow (index num_bins_x + 1) bins.
  for ( int bx = 0; bx <= num_bins_x + 1; ++bx ) {

    // For the current true (x) bin, compute the sum of all reco (y) bins.
    double y_sum = 0.;
    for ( int by = 0; by <= num_bins_y + 1; ++by ) {
      y_sum += smear_hist->GetBinContent( bx, by );
    }

    // Normalize each of the reco (y) bins so that the sum over y is unity.
    for ( int by = 0; by <= num_bins_y + 1; ++by ) {

      // To avoid dividing by zero, set the bin content to zero if the sum of
      // the reco (y) bins is not positive.
      if ( y_sum <= 0. ) {
        //smear_hist->SetBinContent( bx, by, REALLY_SMALL );
        smear_hist->SetBinContent( bx, by, 0. );
      }
      else {
        // Otherwise, normalize in the usual way
        double bc = smear_hist->GetBinContent( bx, by );

        double content = std::max( bc / y_sum, REALLY_SMALL );

        smear_hist->SetBinContent( bx, by, content );
      }
    } // loop over reco (y) bins

  } // loop over true (x) bins

  // Smearing matrix histogram style options
  smear_hist->GetXaxis()->SetTitleFont( FONT_STYLE);
  smear_hist->GetYaxis()->SetTitleFont( FONT_STYLE );
  smear_hist->GetXaxis()->SetTitleSize( 0.05 );
  smear_hist->GetYaxis()->SetTitleSize( 0.05 );
  smear_hist->GetXaxis()->SetLabelFont( FONT_STYLE );
  smear_hist->GetYaxis()->SetLabelFont( FONT_STYLE );
  smear_hist->GetZaxis()->SetLabelFont( FONT_STYLE );
  smear_hist->GetZaxis()->SetLabelSize( 0.03 );
  smear_hist->GetXaxis()->CenterTitle();
  smear_hist->GetYaxis()->CenterTitle();
  smear_hist->GetXaxis()->SetTitleOffset( 1.2 );
  smear_hist->GetYaxis()->SetTitleOffset( 1.1 );
  smear_hist->SetStats( false );
  smear_hist->SetMarkerSize( 1.8 ); // text size
  smear_hist->SetMarkerColor( kWhite ); // text color

  // Draw the smearing matrix plot
  TCanvas* c_smear = new TCanvas;
  c_smear->SetBottomMargin( 0.15 );
  c_smear->SetLeftMargin( 0.13 );

  if ( show_smear_numbers ) {
    // Round all numbers to this precision when rendering them
    gStyle->SetPaintTextFormat( "4.2f" );

    smear_hist->Draw("text colz");
  }
  else {
    smear_hist->Draw( "colz" );
  }

  // For each true bin, print the fraction of events that are reconstructed
  // in the correct corresponding reco bin.
  for ( int bb = 1; bb <= num_reco_bins; ++bb ) {
    std::cout << "bin #" << bb << ": "
      << expected_reco_hist->GetBinLowEdge( bb ) << ", "
      << smear_hist->GetBinContent(bb, bb) << '\n';
  }

}

// Overloaded version that uses a fixed number of equal-width bins
void make_res_plots( const std::string& branchexpr,
  const std::string& variable_title, const std::string& selection,
  const std::set<int>& runs,
  double xmin, double xmax, int Nbins,
  bool show_bin_plots = true,
  bool show_smear_numbers = false,
  int num_true_bins = DEFAULT_TRUE_BINS,
  const std::string& mc_branchexpr = "",
  const std::string& signal_cuts = "mc_is_signal",
  const std::string& mc_event_weight = DEFAULT_MC_EVENT_WEIGHT )
{
  auto low_edges = get_bin_low_edges( xmin, xmax, Nbins );
  return make_res_plots( branchexpr, variable_title, selection, runs,
    low_edges, show_bin_plots, show_smear_numbers, num_true_bins,
    mc_branchexpr, signal_cuts, mc_event_weight );
}

void res_plots() {

  make_res_plots( "p3_mu.CosTheta()", "cos(#theta_{#mu})",
   "sel_CCNp0pi", {1},
   { -1, -0.925, -0.85, -0.775, -0.7, -0.625, -0.55, -0.475, -0.4, -0.325,
     -0.25, -0.175, -0.1, -0.025, 0.05, 0.125, 0.2, 0.275, 0.35, 0.425, 0.5,
      0.575, 0.65, 0.725, 0.8, 0.85, 0.875, 0.9, 0.925, 0.950, 0.975, 1.00 },
   false );

}
